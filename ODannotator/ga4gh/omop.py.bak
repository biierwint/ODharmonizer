# Copyright (C) 2025 A*STAR

# ODmapper (Omics Data Mapping and Harmonizer) is an effort by the
# Data Management Platform in the Bioinformatics Institute (BII),
# Agency of Science, Technology and Research (A*STAR), Singapore.

# This file is part of ODannotator

# ODannotator is an open-source tool.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# http://www.apache.org/licenses/LICENSE-2.0 you can redistribute it and/or modify
# it under the terms of the https://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# You should have received a copy of the Apache License, Version 2.0
# along with this program.  If not, see <https://www.apache.org/licenses/LICENSE-2.0>

'''
This script is part of the ODharmonizer-v1.0 > ODannotator
The purpose of this script is to get annotate variants with OMOP concept_ids.
This script has been added as part of vrs-annotate.

Example usage: vrs-annotate omop --help

'''

import logging
import pickle
from enum import Enum
from pathlib import Path

import requests, os
import json

import pysam

_logger = logging.getLogger(__name__)


class OMOPAnnotatorError(Exception):
    """Custom exceptions for VCF Annotator tool"""


class FieldName(str, Enum):
    """Define VCF field names for OMOP annotations"""

    IDS_FIELD = "VRS_Allele_IDs"
    OMOP_CONCEPT_ID_FIELD = "OMOP_Concept_IDs"	# for OMOP concept_id annotation
    ERROR_FIELD = "OMOP_Error"

# VCF character escape map
VCF_ESCAPE_MAP = str.maketrans(
    {
        "%": "%25",
        ";": "%3B",
        ",": "%2C",
        "\r": "%0D",
        "\n": "%0A",
    }
)


class OMOPAnnotator:
    """Annotate VCFs with OMOP IDs.

    Uses pysam to read, store, and (optionally) output VCFs. Alleles are translated
    into VRS IDs using the VRS-Python translator class.
    """

    def __init__(self, odmapper_base_url) -> None:
        """Initialize the VCFAnnotator class.

        :param data_proxy: GA4GH sequence dataproxy instance.
        """
        self.odmapper_base_url = odmapper_base_url

    def _update_vcf_header(
        self, vcf: pysam.VariantFile
    ) -> None:
        """Add new fields to VCF header

        :param vcf: pysam VCF object to annotate
        :param incl_ref_allele: whether VRS alleles will be calculated for REFs
        :param incl_vrs_attrs: whether INFO properties should be defined for VRS attributes
            (normalized coordinates/state)
        """

        info_field_num = "R"
        info_field_desc = "REF and ALT"

        vcf.header.info.add(
            FieldName.OMOP_CONCEPT_ID_FIELD.value,
            info_field_num,
            "String",
            (
                "The mapped OMOP Genomic concept_id based on the VRS computed identifiers corrresponding to the "
                f"GT indexes of the {info_field_desc} alleles"
            ),
        )
        vcf.header.info.add(
            FieldName.ERROR_FIELD.value,
            ".",
            "String",
            ("If an error occurred during mapping to OMOP concept id, the error message"),
        )

    def annotate(
        self,
        input_vcf_path: Path,
        output_vcf_path: Path | None = None,
        output_pkl_path: Path | None = None,
        odmapper_base_url: str | None = None,
    ) -> None:
        """Given a VCF, produce an output VCF annotated with VRS allele IDs, and/or
        a pickle file containing the full VRS objects.

        :param input_vcf_path: Location of input VCF
        :param output_vcf_path: The path for the output VCF file
        :param output_pkl_path: The path for the output VCF pickle file
        :raise OMOPAnnotatorError: if no output formats are selected
        """
        if not any((output_vcf_path, output_pkl_path)):
            msg = "Must provide one of: `output_vcf_path` or `output_pkl_path`"
            raise OMOPAnnotatorError(msg)

        vcf = pysam.VariantFile(filename=str(input_vcf_path.absolute()))
        if output_vcf_path:
            self._update_vcf_header(vcf)
            vcf_out = pysam.VariantFile(
                str(output_vcf_path.absolute()), "w", header=vcf.header
            )
        else:
            vcf_out = None

        # only retain raw data if dumping to pkl
        omop_data = {} if output_pkl_path else None
        for record in vcf:
            if vcf_out:
                additional_info_fields = [FieldName.OMOP_CONCEPT_ID_FIELD]
            else:
                # no INFO field names need to be designated if not producing an annotated VCF
                additional_info_fields = []
            try:
                omop_field_data = self._get_omop_data(
                    record,
                    omop_data,
                    additional_info_fields,
                    odmapper_base_url,
                )
            except Exception as ex:
                _logger.exception("VRS error on %s-%s", record.chrom, record.pos)
                err_msg = f"{ex}" or f"{type(ex)}"
                err_msg = err_msg.translate(VCF_ESCAPE_MAP)
                additional_info_fields = [FieldName.ERROR_FIELD]
                omop_field_data = {FieldName.ERROR_FIELD.value: [err_msg]}

            #print (additional_info_fields)

            _logger.debug(
                "VCF record %s-%s generated omop_field_data %s",
                record.chrom,
                record.pos,
                omop_field_data,
            )

            if output_vcf_path and vcf_out:
                for k in additional_info_fields:
                    record.info[k.value] = [
                        value or "." for value in omop_field_data[k.value]
                    ]
                vcf_out.write(record)

        vcf.close()

        if vcf_out:
            vcf_out.close()

        if output_pkl_path:
            with output_pkl_path.open("wb") as wf:
                pickle.dump(vrs_data, wf)

    def _get_omop_object(
        self,
        vrs_id: str,
        omop_data: dict | None,
        omop_field_data: dict,
        #odmapper_base_url: 'http://localhost:8000',
        odmapper_base_url,
    ) -> None:
        """Get VRS object given `vcf_coords`. `vrs_data` and `omop_field_data` will
        be mutated.

        :param vcf_coords: Allele to get VRS object for. Format is chr-pos-ref-alt
        :param vrs_data: All constructed VRS objects. Can be `None` if no data dumps
            will be created.
        :param omop_field_data: If `vrs_data`, keys are VRS Fields and values are list
            of VRS data. Empty dict otherwise.
        :param assembly: The assembly used in `vcf_coords`
        :param vrs_data_key: The key to update in `vrs_data`. If not provided, will use
            `vcf_coords` as the key.
        :param vrs_attributes: If `True` will include VRS_Start, VRS_End, VRS_State
            fields in the INFO field. If `False` will not include these fields. Only
            used if `output_vcf` set to `True`.
        :param require_validation: If `True` then validation checks must pass in order
            to return a VRS object. If `False` then VRS object will be returned even if
            validation checks fail. Defaults to `True`.
        """

        if vrs_id:
            concept_id = ""

            url = f'{odmapper_base_url}/synonym/{vrs_id}/'
            response = requests.get(url, verify=False)

            if response.status_code == 200:
                data = response.json()
                if len(data)==0:
                    concept_id = "-"
                else:
                    concept_id += str(response.json().get('concept_id'))
                    #print(concept_id)
            else:
                concept_id = "-"

            omop_field_data[FieldName.OMOP_CONCEPT_ID_FIELD].append(concept_id)

    def _get_omop_data(
        self,
        record: pysam.VariantRecord,
        omop_data: dict | None,
        additional_info_fields: list[FieldName],
        odmapper_base_url,
    ) -> dict:
        """Get VRS data for record's reference and alt alleles.

        :param record: A row in the VCF file
        :param vrs_data: Dictionary containing the VRS object information for the VCF.
            Will be mutated if `output_pickle = True`
        :param assembly: The assembly used in `record`
        :param additional_info_fields: Additional VRS fields to add in INFO field
        :param vrs_attributes: If `True` will include VRS_Start, VRS_End, VRS_State
            fields in the INFO field. If `False` will not include these fields. Only
            used if `output_vcf` set to `True`.
        :param compute_for_ref: If true, compute VRS IDs for the reference allele
        :param require_validation: If `True` then validation checks must pass in
            order to return a VRS object. A `DataProxyValidationError` will be raised if
            validation checks fail. If `False` then VRS object will be returned even if
            validation checks fail. Defaults to `True`.
        :return: A dictionary mapping VRS-related INFO fields to lists of associated
            values. Will be empty if `create_annotated_vcf` is false.
        """
        omop_field_data = {field.value: [] for field in additional_info_fields}

        # Get OMOP data for vrs_id_ref and vrs_id_alt
        vrs_ids = record.info['VRS_Allele_IDs']
        data = f"{record.chrom}-{record.pos}-{record.ref}-{record.alts}"
        id = f"{record.id}"

        for vrs_id in vrs_ids:
            if vrs_id == "-":
                _logger.debug("Unknown VRS ID found: %s", id)
                for field in additional_info_fields:
                    omop_field_data[field.value].append("")
            else:
                self._get_omop_object(
                    vrs_id,
                    omop_data,
                    omop_field_data,
                    odmapper_base_url,
                )

        return omop_field_data
